// Generated by dts-bundle-generator v9.5.1

import React$1 from 'react';
import { RouteProps } from 'react-router-dom';

interface ModulesEvent {
	modules: Record<string, Module$1>;
	canvas: HTMLCanvasElement | null;
}
declare type Module$1 = object;
interface DrawEvent {
	element: IBaseDef;
}
interface ISettingsDefinitionFieldGeneric {
	label: string;
	type: string;
}
type SettingsDefinitionField = ISettingsDefinitionFieldInput | ISettingsDefinitionFieldContainer | ISettingsDefinitionFieldGeneric;
interface ISettingsDefinitionFieldContainer extends ISettingsDefinitionFieldGeneric {
	type: "container";
	fields: SettingsDefinitionField[][];
	collapsable?: boolean;
}
type ISettingsInputValue = string | number | string[] | number[] | Record<string, any> | Record<string, any>[] | undefined;
interface ISettingsDefinitionFieldInput extends ISettingsDefinitionFieldGeneric {
	name: string;
	value: ISettingsInputValue;
}
interface ISettingsDefinitionTab {
	label: string;
	icon?: string;
	fields: SettingsDefinitionField[][];
}
interface ISettingsDefinition {
	details: {
		label: string;
		icon?: string;
	};
	name: string;
	tabs: ISettingsDefinitionTab[];
}
interface ISettingEvent {
	settings: ISettingsDefinition[];
	additional: Record<string, any>;
}
type SettingsEvent = CustomEvent<ISettingEvent>;
declare type XValue = number;
declare type YValue = XValue;
interface IStart {
	x: XValue;
	y: YValue;
}
interface ISize {
	w: XValue;
	h: YValue;
}
interface IArea {
	size: ISize;
	start: IStart;
}
interface IHierarchy {
	parent: IParentDef | null;
	position: number;
}
interface IBaseDef<T = never> {
	[key: symbol | string]: unknown;
	id?: string;
	hierarchy?: IHierarchy;
	start: IStart;
	size: ISize;
	type: string;
	can?: {
		move?: boolean;
		scale?: boolean;
		remove?: boolean;
	};
	area?: IArea;
	data?: T;
}
interface IParentDef extends IBaseDef {
	layout: Layout;
}
type Layout = (IBaseDef | IParentDef)[];
interface EntryConfig {
	source: string | object;
	namespace: string;
	name: string;
	version: string;
	arguments?: unknown[];
}
interface RegisterConfig {
	entry: EntryConfig;
	type: "scope" | "module";
	scope?: boolean;
	tags?: string[];
	requires?: string[];
	lazy?: boolean;
	asset?: {
		src: string;
	};
	resource?: {
		src: string;
	};
}
declare class CModule<T = any> {
	constructor(...args: unknown[]);
	inject?: (injections: T) => void;
}
type Module<T = any> = CModule<T> | Record<string, unknown>;
interface IModuleImportObject {
	default?: Module | ((...args: unknown[]) => void);
}
interface IModuleImport {
	config: RegisterConfig;
	module: IModuleImportObject | (() => Promise<Module>);
}
declare class _IInjectable<T = object> {
	constructor(...args: unknown[]);
	inject(injections: T): void;
	scope?(): Record<string, unknown>;
	static inject: Record<string, string>;
}
type IInjectable<T> = typeof _IInjectable<T>;
declare class Marshal {
	static version: string;
	renderCount: number;
	registered: Record<string, RegisterConfig>;
	loaded: Record<string, object>;
	tagMap: Record<string, IModuleImport[]>;
	scope: Record<string, unknown>;
	instanceMap: WeakMap<Module<any>, RegisterConfig>;
	constructor();
	addScope(name: string, value: unknown): void;
	render(): void;
	register(config: RegisterConfig): void;
	getModuleConstraint(config: RegisterConfig): string;
	get<Type>(key: string): Type | null;
	load(): Promise<void>;
	loadScopes(): Promise<Record<string, RegisterConfig>>;
	updateTagModules(): void;
	tagModules(moduleImport: IModuleImport): void;
	instantiateModule(moduleImport: IModuleImport): Module;
	mapInstance(config: RegisterConfig, module: Module): void;
	getMappedInstance(module: Module): RegisterConfig | undefined;
	loadDependencies(module: Module, config: RegisterConfig): Record<string, object> | undefined | false;
	isESClass(fn: unknown): boolean;
	orderModules(moduleRegistry: Record<string, RegisterConfig>): RegisterConfig[];
	generateLoadGroups(toSend: Record<string, RegisterConfig>): Promise<IModuleImport>[];
	isTag(string: string): boolean;
	import(source: string, addScope?: Record<string, unknown>): Promise<IModuleImportObject>;
	importModule(config: RegisterConfig): Promise<IModuleImportObject>;
	retrieveModulePromise(config: RegisterConfig): Promise<IModuleImport>;
	isObjectEmpty(obj: object): boolean;
}
declare class _ISubscriber {
	static subscriptions: Subscriptions;
}
type ISubscriber = typeof _ISubscriber;
type AmbiguousSubscription = string | Subscription | Subscription[] | EventHandler;
type EventHandler = (event: CustomEvent) => Promise<void> | void;
type Subscriptions = Record<string, AmbiguousSubscription>;
interface Subscription {
	method: string | EventHandler;
	priority?: number;
	constraint?: string | Module | null;
	index?: number;
}
interface ISubscriberObject {
	module: ISubscriber;
	config: RegisterConfig;
}
interface IEventRegistration {
	event: string;
	subscription: AmbiguousSubscription;
	constraint?: string | Module | null;
	sort?: boolean;
	symbol?: symbol | null;
}
interface IInjection extends Record<string, object> {
	subscribers: ISubscriberObject[];
	marshal: Marshal;
}
declare class Herald {
	#private;
	static inject: Record<string, string>;
	inject(injections: IInjection): void;
	dispatch(event: CustomEvent): Promise<void>;
	dispatchSync(event: CustomEvent): void;
	batch(events: IEventRegistration[]): () => void;
	register(event: string, subscription: AmbiguousSubscription, constraint?: string | Module | null, sort?: boolean, symbol?: symbol | null): () => void;
	unregister(event: string, symbol: symbol): void;
}
type PathProps = JSX.IntrinsicAttributes & RouteProps;
interface INavItem {
	node?: React$1.ReactNode;
	label?: string;
	link?: string;
	action?: (e: React$1.MouseEvent<HTMLElement>) => void;
	items?: INavItem[];
}
interface Injected extends Record<string, object> {
	marshal: Marshal;
	herald: Herald;
}
declare class Minstrel {
	#private;
	static inject: Record<string, string>;
	inject(injections: Injected): void;
	setRoute(props: PathProps): void;
	getRoutes(): PathProps[];
	getMenu(): INavItem[];
	addMenuItem(item: INavItem): void;
	setMenu(newMenu: INavItem[]): void;
	getModuleConfig(module: Module): RegisterConfig;
	getResourceUrl(module: Module, suffix: string): string;
	lazy(module: Module, suffix: string, props?: Record<string, any>): React$1.ReactNode;
	component<T>(module: Module, suffix: string, scope?: Record<string, any>): React$1.FC<T>;
	asset(module: Module, suffix: string): string;
}
interface PositionEvent {
	x: number;
	y: number;
}
export interface IWorkspace {
	toRelative: (value: number, direction?: "x" | "y") => string;
	calc: (value: string) => number;
	drawWorkspace: () => void;
	download: (settings: IDownloadSettings) => Promise<void>;
	export: (settings: IExportSettings) => Promise<Blob>;
	scale: (value: number) => number;
	getQuality: () => number;
	setQuality: (quality: any) => void;
	getScale: () => number;
	setScale: (scale: any) => void;
	getSize: () => IWorkspaceSize;
	shouldDrawWorkspace: (toggle: boolean) => void;
	setTranslateLeft: (left: number) => void;
	setTranslateTop: (top: number) => void;
	getTranslate: () => ITranslate;
}
export interface IWorkspaceSize {
	width: number;
	height: number;
}
export declare enum BlobTypes {
	WEBP = "image/webp",
	PNG = "image/png",
	JPG = "image/jpeg"
}
export interface IWorkspaceSettings {
	height?: number;
	width?: number;
	relative?: {
		height?: number;
		width?: number;
	};
}
export interface IExportSettings {
	type?: BlobTypes | string;
	quality?: number;
	dpi?: number;
}
export interface IDownloadSettings extends IExportSettings {
	filename: string;
}
export interface ITranslate {
	left: number;
	top: number;
}
export interface IInjected extends Record<string, object> {
	minstrel: Minstrel;
	herald: Herald;
}
declare enum Event$1 {
	CALC = "antetype.workspace.calc"
}
export interface ICalcEvent<T extends Record<string, any> = Record<string, any>> {
	purpose: string;
	layerType: string;
	values: T;
}
export declare class AntetypeWorkspace {
	#private;
	static inject: Record<string, string>;
	inject(injections: IInjected): void;
	register(event: CustomEvent<ModulesEvent>): Promise<void>;
	draw(event: CustomEvent<DrawEvent>): void;
	setOrigin(): void;
	restoreOrigin(): void;
	calc(event: CustomEvent<ICalcEvent>): void;
	subtractWorkspace(event: CustomEvent<PositionEvent>): void;
	defineSettings(e: SettingsEvent): void;
	static subscriptions: Subscriptions;
}
declare const EnAntetypeWorkspace: IInjectable<IInjected> & ISubscriber;

export {
	EnAntetypeWorkspace as default,
	Event$1 as Event,
};

export {};
